# -*- coding: utf-8 -*-
"""trabalhando com bloxpot

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YXYN7hDyQEZsnBYH8UREXzckqUXzfpK2

#Neste relatório, irei apresentar uma análise dados usando barplot
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
plt.rc('figure', figsize = (14,6))

dados = pd.read_csv('aluguel.csv', sep = ';')
dados

"""#Gráfico mostrando as estatísticas dos valores dos imóveis"""

valores = dados['Valor']
valores

q1 = valores.quantile(.25)
q3 = valores.quantile(.75)
q2 = q3 - q1
print(q2)
limite_interior = q1 - 1.5 * q2
limite_superior = q3 + 1.5 * q2
selecao = (valores >= limite_interior ) & (valores <= limite_superior)
novo_dado = dados[selecao]
novo_dado.hist(['Valor'])

"""#Gráfico sobre as estatísticas dos valores por m2, dos edifícios"""

valores_por_m2 = dados['Valor m2']
valores_por_m2

q1 = valores_por_m2.quantile(.25)
q3 = valores_por_m2.quantile(.75)
q2 = q3 - q1
extremo_inferior = q1 - 1.5 * q2
extremo_superior = q3 + 1.5 * q2
selecao2 = (valores_por_m2 >= extremo_inferior) & (valores_por_m2 <= extremo_superior)
dados_sobre_m2 = dados[selecao2]

dados_sobre_m2.hist(['Valor m2'])

"""#Média dos valores por prédio"""

gropo_valores = dados.groupby(['Tipo'])
novo_frame = gropo_valores['Valor'].mean().round(2)
df = pd.DataFrame(novo_frame).reset_index()
df

plt.figure(figsize=(15,15))
sns.barplot(data = df, x = 'Tipo', y = 'Valor', palette= 'Accent_r')

"""#Quantidade de imóveis por Tipo"""

quantidade_de_imoveis = dados['Tipo'].value_counts()
imoveis = pd.DataFrame(quantidade_de_imoveis).reset_index()
imoveis

plt.figure(figsize = (15,15))
sns.barplot(data = imoveis, x = 'index', y = 'Tipo')

novo_calculo = imoveis['Tipo']
q1 = novo_calculo.quantile(.25)
q3 = novo_calculo.quantile(.75)
q2 = q3 - q1
print(q2)
extremo_inferior = q1 - 1.5 * q2
extremo_superior = q3 + 1.5 * q2
selecao = (novo_calculo >= extremo_inferior) & (novo_calculo <= extremo_superior)
new_data = imoveis[selecao]
new_data.hist(['Tipo'])

#Calculando probabilidade em Python
print('Calculando probabilidade em Python')
print('''Calcularemos a probalidade de determinado imóvel existir dentro da série de imóveis. 
Ou seja, a chance de existir determinado imóvel em nosso
banco de dados com base na quantidade de edifícios''')

input_a = input('Digite o tipo do ímovel:')
list = ['Apartamento', 'Casa de Vila', 'Quitinete', 'Casa de Condomínio', "Casa" ]

if input_a not in list:
  print('''Valor não encontrado, verifique se o valor existe 
  no banco de dados ou verifique se foi digitado corretamente''')
selec = imoveis['index'] == input_a
selec = imoveis[selec] 
selec = int(selec['Tipo'])

universo_ponto_amostral = int(imoveis['Tipo'].sum())

probabilidade = (selec / universo_ponto_amostral)
probabilidade = int(probabilidade * 100)
probabilidade = str(probabilidade) + '%'
print(f'''A chance de você encontrar um imóvel do tipo {input_a},
em nosso banco de dados é de {probabilidade}''')

"""#Banco de dados"""

from pickleshare import main
def banco_de_dados():
  print('''Esse bloco de códigos a baixo 
  mostra um pequeno banco de dados armazenando os valores da
  quantidade de imoveis com base no seu tipo''')
  print(universo_ponto_amostral)
  apartamento = (imoveis['Tipo'] == 16923)
  apartamento = imoveis[apartamento]
  apartamento = int(apartamento['Tipo'])
  print(apartamento)
  casa_de_condominio = (imoveis['Tipo'] == 964)
  casa_de_condominio = (imoveis[casa_de_condominio])
  casa_de_condominio = int(casa_de_condominio['Tipo'])
  print(casa_de_condominio)
  casa = (imoveis['Tipo'] == 898)
  casa = imoveis[casa]
  casa = int(casa['Tipo'])
  print(casa)
  quitinete = imoveis.iloc[3]
  quitinete = int(quitinete['Tipo'])
  print(quitinete)
  casa_de_vila = imoveis.iloc[4]
  casa_de_vila = int(casa_de_vila['Tipo'])
  print(casa_de_vila)
if __name__ == 'main':
  banco_de_dados()

"""#Média do IPTU por tipo  de edifícil"""

calculo_do_iptu = dados.groupby(['Tipo'])
armazenar = calculo_do_iptu['IPTU'].mean().round(3)
armazenar = armazenar.to_frame().reset_index()
armazenar

data = dados['IPTU']
q1 = data.quantile(.25)
q3 = data.quantile(.75)
q2 = q3 - q1
extremo_inferior = q1 - 1.5 * q2
extremo_superior = q1 + 1.5 * q2
selec = (data >= extremo_inferior) & (data <= extremo_superior)
selec2 = dados[selec]
selec2.hist(['IPTU'])

calculo_m_iptu = armazenar['IPTU']
q1 = calculo_m_iptu.quantile(.25)
q3 = calculo_m_iptu.quantile(.75)
q2 = q3 - q1
extremo_inferior = q1 - 1.5 *q2
extremo_superior = q3 + 1.5 *q2
selecao = (calculo_m_iptu <= extremo_superior) & (calculo_m_iptu >= extremo_inferior)
selecao = armazenar[selecao]
selecao.hist(['IPTU'])